Algeasy Text Repository     Naveen Arunachalam
General FormatProblem	Origin	UsesNecessary IntuitionThe AlgorithmExplanation of AlgorithmImplementation (Python)Explanation of Implementation (Python)(Other languages: C++, Java, Matlab)Ideas> Òclosed form solutionsÓ: 1 + 2 + 3 + 4 É vs n(n+1)/2> rubiks cube> towers of Hanoi> Game of Life> Sorting algorithms> API?s?> Pi algorithm> Largest item in a list> Serial and parallel algorithmsProgramming languageshttp://www.academia.edu/7824262/Python_Algorithms_Mastering_Basic_Algorithms_in_the_Python_Languageindex.htmlThis website presents a series of articles that intend to teach the ideas behind computer algorithms. My hope is that readers could build off the information presented here to create their own algorithms and implement them in their language of choice. Articles are targeted to the beginner or intermediate student, with a focus on intuition and understanding. Have fun!contact.htmlNaveen Arun: Site CreatorNaveen Arun is a student who is interested in computers and computer algorithms.Email: narunach@caltech.edu What_is_an_algorithm.htmlBackground: What is an algorithm?	At its most basic level, an algorithm is a roadmap for solving a problem. People create algorithms by thinking about ways to approach a problem, such as sorting objects in a row. Then, to allow computers to execute these algorithms, people create programs in various languages, such as Python, C++, and Java. Programs derived from algorithms are the backbone of nearly every computer process, from simple addition to communication via the Internet.What makes an algorithm useful?	      A useful algorithm solves a general, well-defined problem. For example, let us consider the problem of sorting a list of objects, with the assumption that there is some way of ordering them. There are many instances of this problem ? for instance, consider the differences in sorting the lists {Albert, Calvin, Bob} versus sorting the list {4, 3, 1, 2}. However, the basic idea, sorting a list of objects by some method of ordering, remains constant.            As it turns out, there are many algorithms that solve this problem. One algorithm, which is the one humans use in their everyday lives, is scanning the list, finding the lowest value, and bringing it to the front. Thus, our sorting looks like this:Step 0: {4, 3, 1, 2}Step 1: {1, 4, 3, 2}Step 2: {1, 2, 4, 3}Step 3: {1, 2, 3, 4}	      A more efficient algorithm is Merge Sort. We first group the list in sets of twos, then order those sets of twos as sets of fours, and so on. Our sorting looks like this:Step 0: {4, 3 | 1, 2}Step 1: {3, 4 | 1, 2}Step 2: {1, 2, 3, 4}  Although there are some hidden calculations involved in both examples, one should note that the latter algorithm is good for efficiently sorting large lists, whereas the former can be very inefficient as list sizes grow. The efficiency of Merge Sort comes from the fact that it breaks a large problem into bite-sized pieces which are then combined into a final product.Essentially, there are three things that make an algorithm useful:1. It solves a general, well-defined problem2. It can be applied to different instances of a problem and still yield a valid solution3. It can efficiently solve the problem, regardless of scaleAlgorithms vs. ProgramsAn algorithm is an idea, whereas a program is a series of commands written out for a computer to execute. Algorithms are what a correctly written program should perform. Consider a simple algorithm for microwaving instant noodles:Add boiling waterPlace in microwaveRemove from microwaveNow consider a computer-style ÒprogramÓ to execute this algorithm:Obtain (brand name) instant noodlesObtain waterBoil waterOpen lid of instant noodlesAdd 3/4 cup boiled water to instant noodlesOpen microwaveClose microwaveSet to 60 secondsWait 60 secondsOpen microwaveRemove instant noodlesNotice how this example illustrates a few properties of programs and algorithms:1. An algorithm is an idea that is implemented by a program2. A program is, by nature, more specific than an algorithm3. A program is written for a computer, whereas an algorithm is written for humans to understandBy learning and understanding algorithms, humans can create approaches to complex problems in the real world. Then, these approaches can be written in a computer-friendly format in the form of a program, so that computers can carry out the ideas that humans produce.How are algorithms implemented?As mentioned above, programs implement algorithms by converting a problem into machine-executable code. Some popular means of programming and scripting include C++, Python, Java, and Matlab. These languages allow you to type commands according to specific rules, which are then ÒcompiledÓ into ones and zeroes for computers to understand.[1]When you write your own algorithms, you may come across an instance where you need to use another algorithm to solve a problem. For example, if you want to sort a two-dimensional array of objects both horizontally and vertically, it may help to break the problem into one-dimensional lists in those directions and sort the lists instead. Since many algorithms are built on other algorithms, programming languages often let you import or use popular algorithms in your own programs. For instance, in Python, importing the ÒnumpyÓ package allows operations such as fast list sorting, so that you can save time in writing your own code.Algorithms_and_complexity.htmlSome problems are harder than others. For example, arranging a set of objects in a row is inherently easier than listing out all possible arrangements of objects in a row. In fact, the answer to the first problem is contained in the second problem. Thus, problems have their own inherent complexity, which we wish to quantify.Similarly, algorithms created as solutions to problems carry their own inherent complexity. For example, consider two different algorithms for sorting a list:1. Keep generating random arrangements of the list until the correct one is obtained.2. Arrange the list as a human would, i.e. scanning the list and bringing lowest values to the front.Note that the first algorithm is not even guaranteed to terminate. Nevertheless, for small list sizes, we expect both algorithms to take the same amount of time to complete. However, the second algorithm is more efficient for large list sizes Ð imagine trying to correctly guess the order of a 1000-element list!Now that we know that both problems and solutions come with a certain degree of complexity attached to them, we wish to quantify this complexity in some way.Consider the problem >Scale of problems>Computational Complexity>Big O notation>Polynomial timeBig_O.htmlP_vs_NP.htmlComputers take instructions in steps. An algorithm is a series of such stepsAlgorithms vs ProgramsOrder of the stepsConditionals (if/then/else?)ErrorsComplexity: Understanding Complexity> Multiple ways to do same thingOutline:> ?Algorithm?o basic definitiono etymologyo basic exampleso harder examples[1]Awkward phrasing